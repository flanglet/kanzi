/*
 * This file was generated by the Gradle 'init' task.
 *
 * This project uses @Incubating APIs which are subject to change.
 */

plugins {
    // build
    id 'java-library'
    id 'com.vanniktech.maven.publish' version 'latest.release'
    id 'maven-publish'
    id 'signing'
    id 'biz.aQute.bnd.builder' version "latest.release"

    // QA
    id 'pmd'
    id 'checkstyle'
    id "com.github.spotbugs" version "latest.release"
    id "com.github.hierynomus.license" version "latest.release"
    id "com.diffplug.spotless" version "latest.release"

    // Coverage
    id 'jacoco'

    // Changelog
    id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "latest.release"
}

repositories {
    gradlePluginPortal()
    mavenCentral()

    // Snapshots
    maven {
        url = uri('https://central.sonatype.com/repository/maven-snapshots/')
    }
}

configurations {
    xmlDoclet
}

dependencies {
//    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.11.4'
//    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.11.4'
//    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.11.4'
    testImplementation 'junit:junit:+'

    // Java Doc in XML Format
    xmlDoclet('com.manticore-projects.tools:xml-doclet:+') { changing = true }
}

def getVersion = { boolean considerSnapshot ->
    Integer major = 0
    Integer minor = 0
    Integer patch = null
    Integer build = null
    String commit = null
    String snapshot = ""

    def versionStr = providers.exec {
        commandLine "git", "--no-pager", "-C", project.projectDir, "describe", "--tags", "--always", "--dirty=-SNAPSHOT"
    }.standardOutput.asText.get().trim()

    def pattern = /(?<major>\d*)\.(?<minor>\d*)(\.(?<patch>\d*))?(-(?<build>\d*)-(?<commit>[a-zA-Z\d]*))?/
    def matcher = versionStr =~ pattern

    if (matcher.find()) {
        major = matcher.group('major') as Integer ?: 0
        minor = matcher.group('minor') as Integer ?: 0
        patch = matcher.group('patch') as Integer ?: null
        build = matcher.group('build') as Integer ?: null
        commit = matcher.group('commit') ?: null
    }

    if (considerSnapshot && (versionStr.endsWith('SNAPSHOT') || build != null)) {
        minor++
        if (patch != null) patch = 0
        snapshot = "-SNAPSHOT"
    }

    return "${major}.${minor}" +
            (patch != null ? ".${patch}" : "") +
            (build != null ? ".${build}" : "") +
            snapshot
}

// for publishing a release, call Gradle with Environment Variable RELEASE:
// RELEASE=true gradle JSQLFormatter:publish
version = getVersion(!System.getenv("RELEASE"))

group = 'io.github.flanglet'
description = 'Kanzi Compression'

tasks.register('generateBuildInfo') {
    outputs.dir layout.buildDirectory.file("resources/main")
    doLast {
        def outputDir = new File(layout.buildDirectory.file("generated/sources/buildinfo/java/main").get().asFile, "io/github/flanglet/kanzi")
        outputDir.mkdirs()

        def gitVersionStr = providers.exec {
            commandLine "git", "--no-pager", "-C", project.projectDir, "describe", "--tags", "--always", "--dirty=-SNAPSHOT"
        }.standardOutput.asText.get().trim()

        def gitCommitStr = providers.exec {
            commandLine "git", "--no-pager", "-C", project.projectDir, "rev-parse", "--short", "HEAD"
        }.standardOutput.asText.get().trim()

        def buildTime = Instant.now().toString()

        def content = """\
            |package io.github.flanglet.kanzi;
            |
            |public final class BuildInfo {
            |  public static final String NAME = "${project.name}";
            |  public static final String VERSION = "${gitVersionStr}";
            |  public static final String GIT_COMMIT = "${gitCommitStr ?: 'unknown'}";
            |  public static final String BUILD_TIME = "${buildTime}";
            |}
            """.stripMargin()

        new File(outputDir, "BuildInfo.java").text = content
    }
}

// Make sure the file is included in the compiled sources
sourceSets {
    main {
        java {
            srcDir layout.buildDirectory.file("generated/sources/buildinfo/java/main").get().asFile
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    mustRunAfter("generateBuildInfo")
}

java {
    withSourcesJar()
    //withJavadocJar()

    sourceCompatibility = '11'
    targetCompatibility = '11'

    // needed for XML-Doclet to work (since Doclet changed again with Java 13)
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }

}

jar {
    manifest {
        attributes(
                "Created-By": System.properties['user.name'],
                "Automatic-Module-Name": "io.github.flanglet"
        )
    }

    bundle {
        properties.empty()
        bnd(
                "Created-By": System.properties.get('user.name'),
                "Bundle-SymbolicName": "io.github.flanglet",
                "Import-Package": "*",
                "Export-Package": "io.github.flanglet.*",
                "Automatic-Module-Name": "io.github.flanglet"
        )
    }
}

javadoc {
    if (JavaVersion.current().isJava9Compatible()) {
        options.addBooleanOption('html5', true)
    }
    options.addBooleanOption("Xdoclint:none", true)
}

tasks.register('xmldoc', Javadoc) {
    dependsOn(compileJava)

    def outFile = reporting.file(
            version.endsWith("-SNAPSHOT")
                    ? "xmlDoclet/javadoc_snapshot.xml"
                    : "xmlDoclet/javadoc_stable.xml"
    )
    def rstFile = reporting.file(
            version.endsWith("-SNAPSHOT")
                    ? "xmlDoclet/javadoc_snapshot.md"
                    : "xmlDoclet/javadoc_stable.md"
    )

    source = sourceSets.main.allJava
    classpath = sourceSets.main.runtimeClasspath

    title = "API $version"
    destinationDir = reporting.file("xmlDoclet")
    options.docletpath = configurations.xmlDoclet.files as List
    options.doclet = "com.manticore.tools.xmldoclet.XmlDoclet"
    options.addBooleanOption("md", true)
    options.addBooleanOption("withFloatingToc", true)
    options.addStringOption("basePackage", "io.github.flanglet.kanzi")
    options.addStringOption("filename", outFile.getName())

    copy {
        from rstFile
        into layout.projectDirectory.dir("src/site").asFile
    }
}

test {
    //useJUnitPlatform()
    useJUnit()   // Ensures the JUnit 4 test runner is used

    // set heap size for the test JVM(s)
    minHeapSize = "128m"
    maxHeapSize = "1G"
}

license {
    excludes(["**/*.txt", "**/*.conf", "**/*.sql"])
    includes(["**/*.properties", "**/*.java", "**/*.xml"])

    ext.year = Calendar.getInstance().get(Calendar.YEAR)
    ext.name = 'Andreas Reichel'
    ext.email = 'andreas@manticore-projects.com'

    strictCheck = false
    ignoreFailures = true

    file("../LICENSE")
}


jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
    reports {
        xml.required = true
        csv.required = false
        html.outputLocation = layout.buildDirectory.dir('reports/jacoco')
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = 0.69
            }
            excludes = []
        }
        rule {
            limit {
                counter = 'LINE'
                value = 'MISSEDCOUNT'
                maximum = 800
            }
            excludes = []
        }
    }
}

spotbugsMain {
    reports {
        html {
            destination = file("build/reports/spotbugs/main/spotbugs.html")
            stylesheet = 'fancy-hist.xsl'
        }
    }
}

spotbugs {
    // fail only on P1 and without the net.sf.jsqlparser.parser.*
    excludeFilter = file("config/spotbugs/spotBugsExcludeFilter.xml")

    // do not run over the test, although we should do that eventually
    spotbugsTest.enabled = false
}

pmd {
    consoleOutput = true
    sourceSets = [sourceSets.main]

    // clear the ruleset in order to use configured rules only
    ruleSets = []

    ruleSetFiles = files("config/pmd/ruleset.xml")

    pmdMain {
        excludes = ["build/generated/*"]
    }
}

checkstyle {
    sourceSets = [sourceSets.main, sourceSets.test]
    configFile = rootProject.file('config/checkstyle/checkstyle.xml')
}

spotless {
    // optional: limit format enforcement to just the files changed by this feature branch
    ratchetFrom 'origin/master'

    format 'misc', {
        // define the files to apply `misc` to
        target '*.rst', '*.md', '.gitignore'

        // define the steps to apply to those files
        trimTrailingWhitespace()
        leadingTabsToSpaces(4)
        endWithNewline()
    }
    java {
        leadingTabsToSpaces(4)
        eclipse().configFile('config/formatter/eclipse-java-google-style.xml')
    }
}

tasks.withType(Checkstyle).configureEach {
    reports {
        xml.required = false
        html.required = true
    }
}

mavenPublishing {
    coordinates(group, "kanzi", version)

    pom {
        name = 'JSQLFormatter library'
        description = 'Format and pretty print SQL Statements'
        url = 'https://github.com/flanglet/kanzi'
        licenses {
            license {
                name = 'Apache License 2.0'
                url = 'http://www.apache.org/licenses/LICENSE-2.0'
            }
        }
        developers {
            developer {
                id = 'flanglet'
                name = 'Frederic Langlet'
                email = 'andreas@manticore-projects.com'
            }
            developer {
                id = 'pschichtel'
                name = 'Phillip Schichtel'
                email = 'phillip@schich.tel'
            }
        }
        scm {
            connection = 'scm:git:https://github.com/flanglet/kanzi'
            developerConnection = 'scm:git:git@github.com:flanglet/kanzi'
            url = 'https://github.com/flanglet/kanzi'
        }
    }
}

// Fix signing task dependencies
tasks.withType(AbstractPublishToMaven).configureEach {
    dependsOn(tasks.withType(Sign))
}

signing {
    required { !version.endsWith("SNAPSHOT") && gradle.taskGraph.hasTask("publish") }
}
